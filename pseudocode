Okay, so we have three code modules:
	The Lobby Server, which listens on the network (probably hosted on yujiri.xyz), accepts connections, and creates matches.
	The Game Server, which accepts a network socket for each player (it should be able to be passed these by the Lobby Server), and handles the internal logic of the game. It sends an update out to each client whenever the game state changes or another player sends a message.
	The Client, which connects to the Server, joins a game and handles the display on the player's screen. It probably knows the entire game state. It sends an update to the server whenever the player wants to chat or input a command.


 What does the Python client need to do?
	Receive updates from the server.
	Update the screen based on those updates.
	Take input from the player.
	Send that input back to the server.

For the python client:
	There will be a single mainloop. There are sevreal different modes or 'screens' the player can be at: inputting controls, targeting a Repair card, etc. The mainloop's event detector takes the current screen as an argument and uses that to know what input to take.
	Eventual feature: it could be really nice to be able to enter commands to the client directly.

For the game sever:
	It should dump the gamestate to a file each round, so it can be restoreed.
	Eventual feature: it could be really nice to be able to enter commands to the game server directly.
	Mainloop is listening for reading and writing on each player's socket using select().
	Each chat message it receives will be put into a buffer of some sort that gets parroted out to each player.
	Each round consists of several phases:
		Enemies move.
		Players input actions for their stuff, and can choose to play cards.
		Player stuff happens.
	New waves will arrive on the same countdown no matter if enemies from the last wave are still here.

For the lobby server:
	There will be different missions you can go on.
		Maybe you join a lobby and then vote on a mission, then all choose to accept the result or not. Use rank voting!
	There will be timed and untimed modes.

Classes:
	Gamestate
		__init__(json):
			If json is empty, start a new gamestate. Otherwise go through the process of converting it.
		encode():
			returns a JSON-encoded form of the gamestate.
	Entity - anything with a position on the board
		pos
		image
		rotation
		maxhull
		hull
		maxshield
		shield
		shield_regen_amounts
		shield_regen_pointer
		move()
		already_moved
		stored_action
	Asteroid(Entity)
		move():
			The asteroid has a 33% chance to move 1 space in a random direction.
	Ship(Entity)
		speed
	AlliedShip(Entity) - Allied ships have a few different properties
		
	Component(Entity) - Station component
	Composite(Entity) - Station or large ships that span multiple spaces, can be targeted at different points, and such.
	Station(Composite) - I imagine the Station will have some unique fields/methods.
		components - list
		thrust
		thrust_direction
		shield_generators():
			Returns a list of all the shield generators.
		power_generators()
		factories()
		communications_relays():
			Return True if there are any communications relays.
		rotate():
			how will we handle rotation onto other objects? asteroids can disappear, but ships? Maybe you can't rotate onto a ship.
	Salvage - represents a pile of salvage in space (not an Entity)
		pos
		amount
		time=5
		degenerate():
			Loses 1 time. If no time remaining, amount decreases by 1.
	Hand - Each player has a hand.
	Card
		title - used to determine the effect

Question: how to handle the ontological problem of "distinguishing Drone as an object of Ship and drones as objects of ship"?
	Maybe when you create an object, you can pass it a sort of template string that if recognized auto-sets most of its fields.

A lot of Entity subclass methods seem to need the gamestate. How should I give it to them? I guess I'll just make it a global reference.
